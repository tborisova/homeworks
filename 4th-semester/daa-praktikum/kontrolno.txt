1. strawberries: lower_bound - upper_bound
2. prince: съсед по модул n
3. rezachka: espr1t -> esp1r(t) -> es1p(r) -> e1ps -> 1ep, първият елемент винаги остава + l - 1, counting sort
4. hobbies: индекс на най-голям елемент в инверсия 1 3 4 2 -> 3 в случая, най-голям елемент не на мястото си изваждаме
5. bal: 0 - за ребро, цена по формулата - за ребро, което има по-ниска височина


kruskal: сортираме всички ребрата в графа във възходящ ред

обхождаме ребрата и за всяко ребро: гледаме двата му края, ако u и v не са в една свързана компонента, значи има нужда да се свържат


масив от ребрата, за да го сортираме 
структура от данни - unioun - find(u) find(v) - дали тези две компоненти дали съвпадат
обединяване на две компоненти в една, за да се получи друга union find се нарича тази стурктура
масив от родители

parent[n] = x --- x е parent на n
update родител за обединението

path compression - дърветата стават ниски

m*lgm - сложност на крускал
mlgn - сложност на прим

драсканица - всяка точка с всяка се свързва
няма смисъл да се ползват вектори, може направо матрица на съседство, понеже графа е пълен
прим или крускал

Хипертелепортер - същото, само че се подреждат лексикографски буквите, за да се направят теглата на ребрата.

мостове - мин. покриващо дърво - правителството ги построява и после bfs(пропускливост - множеството от ребра взимаме това с най-малък капацитет)

поддръжка: мин покриващо дърво, всяка седмица се добавят ребра, махаме най-дългото ребро
пазиш най-тежкото ребро в него, а после като се добавя 

while e1...em
  s.erase()
взимаме и гледаме дали реброто е минимално



динамизно програмиране:


f[n] = {-1}

fib(n){
  if(f[n]!= -1) return f[n];
  else{
    res = fib + fib;
    f[n] = res;
    return
  }
}


измислямне на формула + кога се стига до дъното




